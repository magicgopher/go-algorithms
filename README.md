# Go算法和数据结构

## 简介

这是一个用于记录使用 Go 语言实现的算法和数据结构的仓库。

## 时间复杂度

时间复杂度（Time Complexity）是用来衡量一个算法执行时间随输入规模增长而变化的度量。它描述了算法运行时间与输入数据规模之间的关系，通常用大O表示法（Big-O Notation）来表示，忽略常数和低阶项，只关注最高阶项的增长趋势。

数据规模：一般体现在算法的输入参数中。

- 数值：数据规模就是数值的大小。

```go
// Sum 计算从 1 到 n 的所有整数之和，这里入参的 n 就是数据规模
func Sum(n int) int {
	res := 0
	i := 0
	for ; i <= n; i++ {
		res += i
	}
	return res
}
```

- 数组[切片]：数据规模就是数组的长度。

```go
// FindMax 在一个整数切片中查找最大值，这里的入参的 n 就是数据规模
func FindMax(s []int) int {
	if len(s) == 0 {
		return 0 // 空切片返回0
	}
	m := s[0] // 假设第一个元素就是最大值
	for i := 1; i <= len(s)-1; i++ {
		if s[i] > m {
			m = s[i]
		}
	}
	return m
}
```

- 链表：数据规模就是链表的节点数量。

```go
// ListNode 链表结构体
type ListNode struct {
	Val  int
	Next *ListNode
}

// Length 计算单链表的长度
func Length(head *ListNode) int {
	count := 0
	current := head
	for current != nil {
		count++
		current = current.Next
	}
	return count
}
```

如何理解时间复杂度？实际上，一个算法，在不同的配置的机器上，它的执行时间都是不同的，但是，在不同配置的机器上，这个算法的语句执行次数是一样的【这个算法的语句执行次数是一样的指的是：对于相同的输入数据规模 `n`，算法的逻辑决定了基本操作的执行次数是固定的】，所以呢？可以使用语句的执行次数来衡量算法的运行时间。

从下面这个例子来估算算法的执行时间。

```go
func Sum(n int) int {
	res := 0            // (1) 执行1次
	i := 0              // (2) 执行1次
	for ; i <= n; i++ { // (3) 执行了2n次【i<=n; i++是两个语句，每个语句执行了n次】
		res += i 					// (4) 执行了n次
	}
	return res 					// (5) 执行了1次
}
```

示例分析：

- `res := 0` 这行代码执行了1次。
- `i := 0` 这行代码执行了1次。
- `for` 循环中的 `; i <= n; i++` 其中 `i <= n` 执行了n次，`i++` 也执行了n次，这行共执行了2n次。
- `for` 循环中的 `res += 1` 执行了n次。
- `return res` 执行了1次。
- 总共执行了 3n + 3 次

随着数据规模 `n` 的不断增大，系数和常量对执行时间的增长趋势影响非常小，那么这个 `Sum()` 函数的时间复杂度就是 `O(n)`。

为什么随着数据规模 `n` 的不断增大，系数和常量对执行时间的增长趋势影响非常小呢？

下面来看一组数据，如下：

| n     | n+4   |
| ----- | ----- |
| 1     | 5     |
| 10    | 14    |
| 100   | 104   |
| 1000  | 1004  |
| 10000 | 10004 |

## 空间复杂度

空间复杂度（Space complexity）是指算法在执行过程中所需的额外存储空间（不包括输入数据本身占用的空间）。它衡量算法运行时在内存中使用的空间量，通常用大O表示法来描述，反映随着输入规模 n 的增长，算法所需额外空间的变化趋势【算法的存储空间与数据规模之间的增长关系】。

从下面的例子来估算算法的额外空间。

示例1：`O(1)` 空间复杂度

```go
// FindMax 在一个整数切片中查找最大值
func FindMax(s []int) int {
	if len(s) == 0 {
		return 0 // (1) 申请1个常量空间 (用于返回值)
	}
	m := s[0] // (2) 申请1个整型空间 (用于变量 m)
	for i := 1; i <= len(s)-1; i++ { // (3) 申请1个整型空间 (用于变量 i)
		if s[i] > m {
			m = s[i] // (4) 没有新的空间分配
		}
	}
	return m // (5) 没有新的空间分配
}
```

示例分析：

- `FindMax` 函数无论输入的切片 `s` 有多长（即无论 `n` 有多大），它额外申请的内存空间始终是固定的。
- 它只额外申请了变量 `m` 和 `i` 的空间。
- 总共额外申请的空间是 2 个整型变量。
- 这种与数据规模 `n` 无关，始终为常量的额外空间，其空间复杂度就是 *O(1)*。

示例2：`O(n)` 空间复杂度

```go
// CreateArray 创建一个长度为 n 的切片，元素为 0 到 n-1
func CreateArray(n int) []int {
	res := make([]int, n) // (1) 分配一个长度为 n 的切片空间
	i := 0                // (2) 申请1个整型空间 (用于变量 i)
	for ; i < n; i++ {    //
		res[i] = i        // (3) 没有新的空间分配
	}
	return res            // (4) 没有新的空间分配
}
```

示例分析：

- `i := 0` 申请了 1 个整型空间，这是 *O(1)* 的。
- `res := make([]int, n)` 这一行代码，申请了一个长度为 `n` 的 `int` 切片。
- 总共额外申请的空间大小约为 `n * sizeof(int) + 1 * sizeof(int)`。
- 随着数据规模 `n` 的不断增大，这个算法额外申请的内存空间与 `n` 呈线性关系。
- 因此，`CreateArray()` 函数的空间复杂度就是 *O(n)*。

示例3：`O(n)` 空间复杂度（递归）

空间复杂度也包括函数调用栈（Call Stack）所占用的空间。

```go
// RecursiveSum 递归计算 1 到 n 的和
func RecursiveSum(n int) int { // (1) 每次调用，栈上都会分配空间
	if n <= 0 {
		return 0 // (2) 递归终止
	}
	// (3) 递归调用 RecursiveSum(n-1)
	return n + RecursiveSum(n-1) 
}
```

示例分析：

- 当调用 `RecursiveSum(n)` 时，它会接着调用 `RecursiveSum(n-1)`，然后是 `RecursiveSum(n-2)`，以此类推，直到 `RecursiveSum(0)`。
- 在函数 `RecursiveSum(0)` 返回之前，函数调用栈中会同时存在 `n`、`n-1`、`n-2`...`1` 共 `n` 个函数调用帧（Stack Frame）。
- 每一帧都需要空间来存储其参数（如 `n`）和局部状态。
- 因此，这个递归算法消耗的栈空间与数据规模 `n` 呈线性关系。
- 这个函数的空间复杂度也是 *O(n)*。

为什么空间复杂度也忽略常数和系数呢？这和时间复杂度是完全一样的道理。当 `n` 变得非常大时，一个算法是申请了 `n` 个空间，还是 `2n + 10` 个空间，其增长趋势是一致的（都是线性增长）。在大O表示法中，我们只关心这种增长趋势，因此会忽略掉常数（+10）和系数（2），统一记为 *O(n)*。

## 数据结构

- 数组（Array）
- 链表（Linked List）
- 双向链表（Doubly Linked List）
- 跳跃表（Skip List）
- 堆（Heap）
- 栈（Stack）
- 队列（Queue）
- 哈希表（Hash Table）
- 图（Graph）
- 树（Tree）
- 位图（BitMap）
- 

## 算法

- 排序算法
  - 冒泡排序（Bubble Sort）
  - 选择排序（Selection Sort）
  - 插入排序（Insertion Sort）
  - 快速排序（Quick Sort）
  - 堆排序（Heap Sort）
  - 希尔排序（Shell Sort）
  - 归并排序（Merge Sort）